#!/usr/bin/env python3
"""
Claude Code Token Usage Stats Viewer
A beautiful TUI to visualize your Claude Code token consumption.
"""

import json
import sys
import os
import tty
import termios
import select
import re
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

REFRESH_INTERVAL = 2  # seconds
CONTENT_WIDTH = 75  # Fixed content width for centering

STATS_DIR = Path.home() / ".claude" / "stats"
PRICING_FILE = STATS_DIR / "pricing.json"

# Default API pricing per million tokens (as of 2025)
# Source: https://docs.anthropic.com/en/docs/about-claude/pricing
DEFAULT_PRICING = {
    "claude-opus-4-5-20251101": {"input": 5.00, "output": 25.00, "cache_read": 0.50, "cache_write": 6.25},
    "claude-sonnet-4-20250514": {"input": 3.00, "output": 15.00, "cache_read": 0.30, "cache_write": 3.75},
    "claude-3-5-sonnet-20241022": {"input": 3.00, "output": 15.00, "cache_read": 0.30, "cache_write": 3.75},
    "claude-3-5-haiku-20241022": {"input": 0.80, "output": 4.00, "cache_read": 0.08, "cache_write": 1.00},
}

# Fallback pricing by model family (used when specific model not found)
FAMILY_PRICING = {
    "opus": {"input": 15.00, "output": 75.00, "cache_read": 1.50, "cache_write": 18.75},
    "sonnet": {"input": 3.00, "output": 15.00, "cache_read": 0.30, "cache_write": 3.75},
    "haiku": {"input": 1.00, "output": 5.00, "cache_read": 0.10, "cache_write": 1.25},
}


def get_family_pricing(model: str) -> dict:
    """Get fallback pricing based on model family (opus/sonnet/haiku)."""
    model_lower = model.lower()
    if "opus" in model_lower:
        return FAMILY_PRICING["opus"]
    elif "haiku" in model_lower:
        return FAMILY_PRICING["haiku"]
    return FAMILY_PRICING["sonnet"]


def load_pricing() -> dict:
    """Load pricing from user config file merged with defaults."""
    pricing = DEFAULT_PRICING.copy()

    # Load user overrides (highest priority)
    if PRICING_FILE.exists():
        try:
            with open(PRICING_FILE, "r") as f:
                custom = json.load(f)
                pricing.update(custom)
        except (json.JSONDecodeError, IOError):
            pass

    return pricing


def get_model_pricing(model: str, pricing: dict) -> dict:
    """Get pricing for a model. Falls back to family pricing for unknown models."""
    # Direct match
    if model in pricing:
        return pricing[model]

    # Partial match
    for key in pricing:
        if key in model or model in key:
            return pricing[key]

    # Fallback to family-based pricing
    return get_family_pricing(model)


def calculate_cost(tokens: dict, model: str, pricing: dict) -> float:
    """Calculate cost for given token counts."""
    mp = get_model_pricing(model, pricing)
    cost = 0.0
    cost += (tokens.get("input_tokens", 0) / 1_000_000) * mp.get("input", 0)
    cost += (tokens.get("output_tokens", 0) / 1_000_000) * mp.get("output", 0)
    cost += (tokens.get("cache_read_tokens", 0) / 1_000_000) * mp.get("cache_read", 0)
    cost += (tokens.get("cache_creation_tokens", 0) / 1_000_000) * mp.get("cache_write", 0)
    return cost


def format_cost(cost: float) -> str:
    """Format cost with appropriate precision."""
    if cost >= 100:
        return f"${cost:,.0f}"
    elif cost >= 10:
        return f"${cost:.2f}"
    elif cost >= 0.01:
        return f"${cost:.3f}"
    elif cost > 0:
        return f"${cost:.4f}"
    return "$0.00"


def get_cost_color(cost: float) -> str:
    """Return ANSI color code based on cost magnitude."""
    if cost >= 10:
        return "\033[91m"  # BRIGHT_RED
    elif cost >= 1:
        return "\033[93m"  # BRIGHT_YELLOW
    return "\033[92m"  # BRIGHT_GREEN


def get_terminal_width() -> int:
    """Get terminal width."""
    try:
        return os.get_terminal_size().columns
    except OSError:
        return 80


def strip_ansi(text: str) -> str:
    """Remove ANSI escape codes from text."""
    return re.sub(r'\033\[[0-9;]*m', '', text)


def center_line(line: str, width: int) -> str:
    """Center a line within the given width."""
    visible_len = len(strip_ansi(line))
    padding = (width - min(visible_len, CONTENT_WIDTH)) // 2
    if padding > 0:
        return ' ' * padding + line
    return line


def center_output(lines: list[str]) -> list[str]:
    """Center all lines based on terminal width."""
    term_width = get_terminal_width()
    return [center_line(line, term_width) for line in lines]


class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    UNDERLINE = "\033[4m"
    REVERSE = "\033[7m"

    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    MAGENTA = "\033[35m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"

    BRIGHT_RED = "\033[91m"
    BRIGHT_GREEN = "\033[92m"
    BRIGHT_YELLOW = "\033[93m"
    BRIGHT_BLUE = "\033[94m"
    BRIGHT_MAGENTA = "\033[95m"
    BRIGHT_CYAN = "\033[96m"
    BRIGHT_WHITE = "\033[97m"


# Block characters for graphs
BLOCKS = {
    'full': '‚ñà',
    'seven_eighths': '‚ñâ',
    'three_quarters': '‚ñä',
    'five_eighths': '‚ñã',
    'half': '‚ñå',
    'three_eighths': '‚ñç',
    'quarter': '‚ñé',
    'eighth': '‚ñè',
    'empty': '‚ñë',
}

SPARK = " ‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà"

MODEL_COLORS = {
    "claude-opus-4-5-20251101": (Colors.BRIGHT_MAGENTA, "Opus 4.5"),
    "claude-sonnet-4-20250514": (Colors.BRIGHT_BLUE, "Sonnet 4"),
    "claude-3-5-sonnet-20241022": (Colors.BLUE, "Sonnet 3.5"),
    "claude-3-5-haiku-20241022": (Colors.CYAN, "Haiku 3.5"),
    "claude-haiku": (Colors.CYAN, "Haiku"),
}


def get_model_display(model: str) -> tuple:
    if model in MODEL_COLORS:
        return MODEL_COLORS[model]
    for key, val in MODEL_COLORS.items():
        if key in model or model in key:
            return val
    return (Colors.BRIGHT_WHITE, model[:20])


def format_number(n: int) -> str:
    return f"{n:,}"


def format_tokens_short(n: int) -> str:
    if n >= 1_000_000:
        return f"{n/1_000_000:.1f}M"
    elif n >= 1_000:
        return f"{n/1_000:.1f}K"
    return str(n)


def load_stats(date_str: str) -> Optional[dict]:
    stats_file = STATS_DIR / f"{date_str}.json"
    if stats_file.exists():
        try:
            with open(stats_file, "r") as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            pass
    return None


def aggregate_stats(from_date: str, to_date: str) -> dict:
    """Aggregate stats across a date range with detailed daily breakdown."""
    pricing = load_pricing()
    result = {
        "input_tokens": 0,
        "output_tokens": 0,
        "cache_read_tokens": 0,
        "cache_creation_tokens": 0,
        "total_tokens": 0,
        "request_count": 0,
        "session_count": 0,
        "cost": 0.0,
        "by_model": {},
        "daily": [],
    }

    current = datetime.strptime(from_date, "%Y-%m-%d")
    end = datetime.strptime(to_date, "%Y-%m-%d")

    while current <= end:
        date_str = current.strftime("%Y-%m-%d")
        stats = load_stats(date_str)

        daily_entry = {
            "date": date_str,
            "input_tokens": 0,
            "output_tokens": 0,
            "cache_read_tokens": 0,
            "cache_creation_tokens": 0,
            "total_tokens": 0,
            "request_count": 0,
            "session_count": 0,
            "cost": 0.0,
        }

        if stats:
            totals = stats.get("daily_totals", {})
            daily_entry["input_tokens"] = totals.get("input_tokens", 0)
            daily_entry["output_tokens"] = totals.get("output_tokens", 0)
            daily_entry["cache_read_tokens"] = totals.get("cache_read_tokens", 0)
            daily_entry["cache_creation_tokens"] = totals.get("cache_creation_tokens", 0)
            daily_entry["total_tokens"] = totals.get("total_tokens", 0)
            daily_entry["request_count"] = totals.get("request_count", 0)
            daily_entry["session_count"] = totals.get("session_count", 0)
            daily_entry["cost"] = totals.get("cost", 0.0)

            # Recalculate cost if not stored (backward compatibility)
            if daily_entry["cost"] == 0.0 and daily_entry["total_tokens"] > 0:
                for model, ms in stats.get("by_model", {}).items():
                    daily_entry["cost"] += calculate_cost(ms, model, pricing)

            result["input_tokens"] += daily_entry["input_tokens"]
            result["output_tokens"] += daily_entry["output_tokens"]
            result["cache_read_tokens"] += daily_entry["cache_read_tokens"]
            result["cache_creation_tokens"] += daily_entry["cache_creation_tokens"]
            result["total_tokens"] += daily_entry["total_tokens"]
            result["request_count"] += daily_entry["request_count"]
            result["session_count"] += daily_entry["session_count"]
            result["cost"] += daily_entry["cost"]

            for model, model_stats in stats.get("by_model", {}).items():
                if model not in result["by_model"]:
                    result["by_model"][model] = {
                        "input_tokens": 0,
                        "output_tokens": 0,
                        "cache_read_tokens": 0,
                        "cache_creation_tokens": 0,
                        "request_count": 0,
                        "cost": 0.0,
                    }
                for key in ["input_tokens", "output_tokens", "cache_read_tokens", "cache_creation_tokens", "request_count"]:
                    result["by_model"][model][key] += model_stats.get(key, 0)
                # Aggregate cost, recalculate if not stored
                model_cost = model_stats.get("cost", 0.0)
                if model_cost == 0.0:
                    model_cost = calculate_cost(model_stats, model, pricing)
                result["by_model"][model]["cost"] += model_cost

        result["daily"].append(daily_entry)
        current += timedelta(days=1)

    return result


def get_key(timeout: float = REFRESH_INTERVAL):
    """Get a single keypress with timeout. Returns None if no key pressed."""
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        # Wait for input with timeout
        rlist, _, _ = select.select([sys.stdin], [], [], timeout)
        if not rlist:
            return None  # Timeout, no key pressed

        ch = sys.stdin.read(1)
        if ch == '\x1b':
            # Check if more chars available for escape sequence
            rlist, _, _ = select.select([sys.stdin], [], [], 0.01)
            if rlist:
                ch2 = sys.stdin.read(1)
                if ch2 == '[':
                    rlist, _, _ = select.select([sys.stdin], [], [], 0.01)
                    if rlist:
                        ch3 = sys.stdin.read(1)
                        if ch3 == 'A':
                            return 'UP'
                        elif ch3 == 'B':
                            return 'DOWN'
                        elif ch3 == 'C':
                            return 'RIGHT'
                        elif ch3 == 'D':
                            return 'LEFT'
            return 'ESC'
        return ch
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)


def sparkline(values: list, width: int = 7) -> str:
    if not values or max(values) == 0:
        return SPARK[0] * width
    max_val = max(values)
    result = ""
    for v in values[-width:]:
        idx = int((v / max_val) * (len(SPARK) - 1)) if max_val > 0 else 0
        result += SPARK[idx]
    return result.ljust(width, SPARK[0])


def mini_bar(value: int, max_val: int, width: int = 10, char: str = '‚ñà', empty: str = ' ') -> str:
    """Create a mini horizontal bar."""
    if max_val == 0 or value == 0:
        return ' ' * width
    filled = int((value / max_val) * width)
    if filled == 0 and value > 0:
        filled = 1  # Show at least 1 char if non-zero
    return char * filled + ' ' * (width - filled)


def clear_screen():
    print("\033[2J\033[H", end="", flush=True)


def hide_cursor():
    print("\033[?25l", end="", flush=True)


def show_cursor():
    print("\033[?25h", end="", flush=True)


def draw_header() -> list[str]:
    lines = []
    now = datetime.now()
    lines.append("")
    lines.append(f"  {Colors.BOLD}{Colors.BRIGHT_CYAN}‚ï≠{'‚îÄ' * 50}‚ïÆ{Colors.RESET}")
    lines.append(f"  {Colors.BOLD}{Colors.BRIGHT_CYAN}‚îÇ{Colors.BRIGHT_WHITE}        ‚ö° CLAUDE CODE TOKEN STATS ‚ö°            {Colors.BRIGHT_CYAN}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BOLD}{Colors.BRIGHT_CYAN}‚ï∞{'‚îÄ' * 50}‚ïØ{Colors.RESET}")
    lines.append(f"  {Colors.DIM}{now.strftime('%A, %B %d, %Y ‚Ä¢ %H:%M')}{Colors.RESET}")
    lines.append("")
    return lines


def draw_date_picker(from_date: datetime, to_date: datetime, selected: int) -> list[str]:
    lines = []
    lines.append(f"  {Colors.BOLD}üìÖ Date Range{Colors.RESET}  {Colors.DIM}‚Üê‚Üí switch  ‚Üë‚Üì adjust  T today  W week  M month  Q quit{Colors.RESET}")
    lines.append("")

    from_str = from_date.strftime("%Y-%m-%d")
    to_str = to_date.strftime("%Y-%m-%d")

    if selected == 0:
        from_style = f"{Colors.REVERSE}{Colors.BRIGHT_CYAN}"
        to_style = Colors.DIM
    else:
        from_style = Colors.DIM
        to_style = f"{Colors.REVERSE}{Colors.BRIGHT_CYAN}"

    lines.append(f"  {Colors.CYAN}From:{Colors.RESET} {from_style} {from_str} {Colors.RESET}    {Colors.CYAN}To:{Colors.RESET} {to_style} {to_str} {Colors.RESET}")
    lines.append("")

    return lines


def draw_summary(stats: dict, from_date: str, to_date: str) -> list[str]:
    lines = []

    from_dt = datetime.strptime(from_date, "%Y-%m-%d")
    to_dt = datetime.strptime(to_date, "%Y-%m-%d")
    days = (to_dt - from_dt).days + 1

    if from_date == to_date:
        range_label = from_dt.strftime("%b %d, %Y")
    else:
        range_label = f"{from_dt.strftime('%b %d')} ‚Üí {to_dt.strftime('%b %d, %Y')} ({days} days)"

    lines.append(f"  {Colors.BOLD}{Colors.GREEN}üìä Summary: {range_label}{Colors.RESET}")
    lines.append(f"  {Colors.DIM}{'‚îÄ' * 70}{Colors.RESET}")

    # Calculate non-cached vs cached
    non_cached = stats['input_tokens'] + stats['output_tokens']
    cached = stats['cache_read_tokens'] + stats['cache_creation_tokens']
    total = stats['total_tokens']

    total_cost = stats.get('cost', 0.0)
    cost_color = get_cost_color(total_cost)

    lines.append("")
    lines.append(f"  {Colors.BRIGHT_WHITE}{Colors.BOLD}TOTAL{Colors.RESET}          {Colors.BRIGHT_GREEN}{format_number(total):>15}{Colors.RESET}   {Colors.DIM}‚îÇ{Colors.RESET}  {cost_color}{Colors.BOLD}{format_cost(total_cost)}{Colors.RESET}  {Colors.DIM}‚îÇ{Colors.RESET}  Sessions: {stats['session_count']}  Requests: {stats['request_count']}")
    lines.append("")

    # Non-cached section
    lines.append(f"  {Colors.BOLD}Direct (non-cached){Colors.RESET}                    {Colors.BOLD}Cached{Colors.RESET}")
    lines.append(f"  {Colors.CYAN}‚Üì Input{Colors.RESET}    {format_number(stats['input_tokens']):>12}          {Colors.YELLOW}‚Üì Read{Colors.RESET}     {format_number(stats['cache_read_tokens']):>12}")
    lines.append(f"  {Colors.MAGENTA}‚Üë Output{Colors.RESET}   {format_number(stats['output_tokens']):>12}          {Colors.BLUE}‚Üë Write{Colors.RESET}    {format_number(stats['cache_creation_tokens']):>12}")
    lines.append(f"  {Colors.DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ{Colors.RESET}                 {Colors.DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ{Colors.RESET}")
    lines.append(f"  {Colors.WHITE}Subtotal{Colors.RESET}   {format_number(non_cached):>12}          {Colors.WHITE}Subtotal{Colors.RESET}   {format_number(cached):>12}")
    lines.append("")

    return lines


def draw_model_breakdown(by_model: dict) -> list[str]:
    lines = []
    if not by_model:
        return lines

    lines.append(f"  {Colors.BOLD}Per-Model Breakdown{Colors.RESET}")
    lines.append(f"  {Colors.DIM}{'‚îÄ' * 75}{Colors.RESET}")
    # Header with fixed column widths
    lines.append(
        f"  {Colors.DIM}{'Model':<14}{'‚ÜìInput':>10}{'‚ÜëOutput':>10}{'Cache‚Üì':>10}{'Cache‚Üë':>10}{'Total':>10}{'Cost':>11}{Colors.RESET}"
    )

    for model, s in sorted(by_model.items()):
        color, display_name = get_model_display(model)
        total = s.get("input_tokens", 0) + s.get("output_tokens", 0) + s.get("cache_read_tokens", 0) + s.get("cache_creation_tokens", 0)
        cost = s.get("cost", 0.0)
        cost_color = get_cost_color(cost)
        lines.append(
            f"  {color}{display_name:<14}{Colors.RESET}"
            f"{Colors.CYAN}{format_tokens_short(s.get('input_tokens', 0)):>10}{Colors.RESET}"
            f"{Colors.MAGENTA}{format_tokens_short(s.get('output_tokens', 0)):>10}{Colors.RESET}"
            f"{Colors.YELLOW}{format_tokens_short(s.get('cache_read_tokens', 0)):>10}{Colors.RESET}"
            f"{Colors.BLUE}{format_tokens_short(s.get('cache_creation_tokens', 0)):>10}{Colors.RESET}"
            f"{Colors.BRIGHT_WHITE}{format_tokens_short(total):>10}{Colors.RESET}"
            f"{cost_color}{format_cost(cost):>11}{Colors.RESET}"
        )

    lines.append("")
    return lines


def draw_daily_breakdown(daily: list[dict]) -> list[str]:
    """Draw detailed daily breakdown with mini graphs."""
    lines = []

    if not daily:
        return lines

    # Calculate maxes for scaling
    max_input = max(d["input_tokens"] for d in daily) or 1
    max_output = max(d["output_tokens"] for d in daily) or 1
    max_cache_r = max(d["cache_read_tokens"] for d in daily) or 1
    max_cache_w = max(d["cache_creation_tokens"] for d in daily) or 1

    # Limit display to last 10 days if too many
    display_daily = daily[-10:] if len(daily) > 10 else daily

    # Column widths: date=8, bar+val=14 each (6 bar + 8 val), total=10, cost=10
    lines.append(f"  {Colors.BOLD}Daily Breakdown{Colors.RESET}")
    lines.append(f"  {Colors.DIM}{'‚îÄ' * 75}{Colors.RESET}")
    lines.append(
        f"  {Colors.DIM}{'Date':<8}{'‚ÜìInput':>14}{'‚ÜëOutput':>14}{'Cache‚Üì':>14}{'Cache‚Üë':>14}{'Total':>10}{'Cost':>10}{Colors.RESET}"
    )

    for d in display_daily:
        date_obj = datetime.strptime(d["date"], "%Y-%m-%d")
        is_today = d["date"] == datetime.now().strftime("%Y-%m-%d")

        if is_today:
            date_str = f"{Colors.BRIGHT_GREEN}{date_obj.strftime('%b %d'):<8}{Colors.RESET}"
            marker = " ‚óÄ"
        else:
            date_str = f"{Colors.DIM}{date_obj.strftime('%b %d'):<8}{Colors.RESET}"
            marker = ""

        # Mini bars for each metric (6 chars) + value (8 chars) = 14 total
        bar_w = 6
        inp_bar = mini_bar(d["input_tokens"], max_input, bar_w)
        out_bar = mini_bar(d["output_tokens"], max_output, bar_w)
        cr_bar = mini_bar(d["cache_read_tokens"], max_cache_r, bar_w)
        cw_bar = mini_bar(d["cache_creation_tokens"], max_cache_w, bar_w)

        inp_val = format_tokens_short(d["input_tokens"])
        out_val = format_tokens_short(d["output_tokens"])
        cr_val = format_tokens_short(d["cache_read_tokens"])
        cw_val = format_tokens_short(d["cache_creation_tokens"])
        total_val = format_tokens_short(d["total_tokens"])
        cost = d.get("cost", 0.0)
        cost_color = get_cost_color(cost)

        lines.append(
            f"  {date_str}"
            f"{Colors.CYAN}{inp_bar}{inp_val:>8}{Colors.RESET}"
            f"{Colors.MAGENTA}{out_bar}{out_val:>8}{Colors.RESET}"
            f"{Colors.YELLOW}{cr_bar}{cr_val:>8}{Colors.RESET}"
            f"{Colors.BLUE}{cw_bar}{cw_val:>8}{Colors.RESET}"
            f"{Colors.BRIGHT_WHITE}{total_val:>10}{Colors.RESET}"
            f"{cost_color}{format_cost(cost):>10}{Colors.RESET}{marker}"
        )

    if len(daily) > 10:
        lines.append(f"  {Colors.DIM}... showing last 10 of {len(daily)} days{Colors.RESET}")

    lines.append("")
    return lines


def sparkline_float(values: list, width: int = 7) -> str:
    """Sparkline for float values (like costs)."""
    if not values or max(values) == 0:
        return SPARK[0] * width
    max_val = max(values)
    result = ""
    for v in values[-width:]:
        idx = int((v / max_val) * (len(SPARK) - 1)) if max_val > 0 else 0
        result += SPARK[idx]
    return result.ljust(width, SPARK[0])


def draw_sparkline_graphs(daily: list[dict]) -> list[str]:
    """Draw sparkline trend graphs."""
    lines = []

    if not daily or len(daily) < 2:
        return lines

    lines.append(f"  {Colors.BOLD}Trends{Colors.RESET} {Colors.DIM}(last {len(daily)} days){Colors.RESET}")
    lines.append(f"  {Colors.DIM}{'‚îÄ' * 40}{Colors.RESET}")

    # Extract values
    inputs = [d["input_tokens"] for d in daily]
    outputs = [d["output_tokens"] for d in daily]
    cache_r = [d["cache_read_tokens"] for d in daily]
    cache_w = [d["cache_creation_tokens"] for d in daily]
    totals = [d["total_tokens"] for d in daily]
    costs = [d.get("cost", 0.0) for d in daily]

    spark_width = min(len(daily), 14)
    total_cost = sum(costs)
    cost_color = get_cost_color(total_cost)

    lines.append(f"  {Colors.CYAN}Input    {Colors.RESET} {Colors.CYAN}{sparkline(inputs, spark_width)}{Colors.RESET}  {Colors.DIM}{format_tokens_short(sum(inputs))}{Colors.RESET}")
    lines.append(f"  {Colors.MAGENTA}Output   {Colors.RESET} {Colors.MAGENTA}{sparkline(outputs, spark_width)}{Colors.RESET}  {Colors.DIM}{format_tokens_short(sum(outputs))}{Colors.RESET}")
    lines.append(f"  {Colors.YELLOW}Cache R  {Colors.RESET} {Colors.YELLOW}{sparkline(cache_r, spark_width)}{Colors.RESET}  {Colors.DIM}{format_tokens_short(sum(cache_r))}{Colors.RESET}")
    lines.append(f"  {Colors.BLUE}Cache W  {Colors.RESET} {Colors.BLUE}{sparkline(cache_w, spark_width)}{Colors.RESET}  {Colors.DIM}{format_tokens_short(sum(cache_w))}{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_WHITE}Total    {Colors.RESET} {Colors.BRIGHT_GREEN}{sparkline(totals, spark_width)}{Colors.RESET}  {Colors.DIM}{format_tokens_short(sum(totals))}{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_YELLOW}Cost     {Colors.RESET} {Colors.BRIGHT_YELLOW}{sparkline_float(costs, spark_width)}{Colors.RESET}  {cost_color}{format_cost(total_cost)}{Colors.RESET}")
    lines.append("")

    return lines


def draw_stacked_bar_chart(daily: list[dict]) -> list[str]:
    """Draw a stacked bar chart showing composition."""
    lines = []

    if not daily:
        return lines

    display_daily = daily[-7:] if len(daily) > 7 else daily
    max_total = max(d["total_tokens"] for d in display_daily) or 1

    lines.append(f"  {Colors.BOLD}Composition{Colors.RESET} {Colors.DIM}(stacked){Colors.RESET}")
    lines.append(f"  {Colors.DIM}{'‚îÄ' * 50}{Colors.RESET}")
    lines.append(f"  {Colors.DIM}Legend: {Colors.CYAN}‚ñ†{Colors.RESET}{Colors.DIM}Input {Colors.MAGENTA}‚ñ†{Colors.RESET}{Colors.DIM}Output {Colors.YELLOW}‚ñ†{Colors.RESET}{Colors.DIM}CacheR {Colors.BLUE}‚ñ†{Colors.RESET}{Colors.DIM}CacheW{Colors.RESET}")
    lines.append("")

    bar_width = 35

    for d in display_daily:
        date_obj = datetime.strptime(d["date"], "%Y-%m-%d")
        is_today = d["date"] == datetime.now().strftime("%Y-%m-%d")

        if is_today:
            date_str = f"{Colors.BRIGHT_GREEN}{date_obj.strftime('%a')}{Colors.RESET}"
        else:
            date_str = f"{Colors.DIM}{date_obj.strftime('%a')}{Colors.RESET}"

        total = d["total_tokens"]
        if total == 0:
            lines.append(f"  {date_str:>10} {Colors.DIM}{'‚ñë' * bar_width}{Colors.RESET}      0")
            continue

        # Calculate proportions
        scale = bar_width / max_total
        inp_w = int(d["input_tokens"] * scale)
        out_w = int(d["output_tokens"] * scale)
        cr_w = int(d["cache_read_tokens"] * scale)
        cw_w = int(d["cache_creation_tokens"] * scale)

        # Ensure at least 1 char if non-zero
        if d["input_tokens"] > 0 and inp_w == 0:
            inp_w = 1
        if d["output_tokens"] > 0 and out_w == 0:
            out_w = 1
        if d["cache_read_tokens"] > 0 and cr_w == 0:
            cr_w = 1
        if d["cache_creation_tokens"] > 0 and cw_w == 0:
            cw_w = 1

        # Build stacked bar
        bar = (
            f"{Colors.CYAN}{'‚ñà' * inp_w}{Colors.RESET}"
            f"{Colors.MAGENTA}{'‚ñà' * out_w}{Colors.RESET}"
            f"{Colors.YELLOW}{'‚ñà' * cr_w}{Colors.RESET}"
            f"{Colors.BLUE}{'‚ñà' * cw_w}{Colors.RESET}"
        )

        # Pad to width
        used = inp_w + out_w + cr_w + cw_w
        padding = bar_width - used
        if padding > 0:
            bar += f"{Colors.DIM}{'‚ñë' * padding}{Colors.RESET}"

        lines.append(f"  {date_str:>10} {bar} {format_tokens_short(total):>6}")

    lines.append("")
    return lines


def interactive_mode():
    """Run interactive date picker mode."""
    today = datetime.now()
    from_date = today - timedelta(days=6)
    to_date = today
    selected = 0

    hide_cursor()

    try:
        while True:
            clear_screen()

            from_str = from_date.strftime("%Y-%m-%d")
            to_str = to_date.strftime("%Y-%m-%d")

            stats = aggregate_stats(from_str, to_str)

            output = []
            output.extend(draw_header())
            output.extend(draw_date_picker(from_date, to_date, selected))
            output.extend(draw_summary(stats, from_str, to_str))
            output.extend(draw_model_breakdown(stats.get("by_model", {})))
            output.extend(draw_sparkline_graphs(stats.get("daily", [])))
            output.extend(draw_daily_breakdown(stats.get("daily", [])))
            output.append(f"  {Colors.DIM}Stats: ~/.claude/stats/  ‚Ä¢  Auto-refreshing every {REFRESH_INTERVAL}s{Colors.RESET}")
            output.append("")

            print("\n".join(center_output(output)), flush=True)

            key = get_key()

            if key is None:
                continue  # Auto-refresh on timeout
            elif key in ('q', 'Q', '\x03'):
                break
            elif key == 'LEFT':
                selected = 0
            elif key == 'RIGHT':
                selected = 1
            elif key == 'UP':
                if selected == 0:
                    from_date += timedelta(days=1)
                    if from_date > to_date:
                        from_date = to_date
                else:
                    to_date += timedelta(days=1)
                    if to_date > today:
                        to_date = today
            elif key == 'DOWN':
                if selected == 0:
                    from_date -= timedelta(days=1)
                else:
                    to_date -= timedelta(days=1)
                    if to_date < from_date:
                        to_date = from_date
            elif key == 't' or key == 'T':
                from_date = today
                to_date = today
            elif key == 'w' or key == 'W':
                from_date = today - timedelta(days=6)
                to_date = today
            elif key == 'm' or key == 'M':
                from_date = today - timedelta(days=29)
                to_date = today

    finally:
        show_cursor()
        clear_screen()


def main():
    if len(sys.argv) > 1 and sys.argv[1] in ('-h', '--help'):
        print(f"""
{Colors.BOLD}Claude Code Token Stats{Colors.RESET}

Usage:
  claude-stats           Interactive mode with date picker

Interactive controls:
  ‚Üê/‚Üí     Switch between From/To dates
  ‚Üë/‚Üì     Adjust selected date by 1 day
  T       Today only
  W       Last 7 days (Week)
  M       Last 30 days (Month)
  Q       Quit

{Colors.DIM}Legend:{Colors.RESET}
  {Colors.CYAN}‚ñ† Input{Colors.RESET}     Direct input tokens
  {Colors.MAGENTA}‚ñ† Output{Colors.RESET}    Direct output tokens
  {Colors.YELLOW}‚ñ† Cache R{Colors.RESET}   Cache read tokens
  {Colors.BLUE}‚ñ† Cache W{Colors.RESET}   Cache write tokens
""")
    else:
        interactive_mode()


if __name__ == "__main__":
    main()
