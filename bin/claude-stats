#!/usr/bin/env python3
"""
Claude Code Token Usage Stats Viewer
A beautiful TUI to visualize your Claude Code token consumption.
"""

import json
import sys
import os
import tty
import termios
import select
import signal
import re
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

# Add lib directory to path for shared modules
_script_dir = Path(__file__).resolve().parent
for _lib_path in [_script_dir.parent / "lib", Path.home() / ".claude" / "lib"]:
    if _lib_path.exists():
        sys.path.insert(0, str(_lib_path))
        break

# Try to import from shared module, fallback to inline definitions for backward compatibility
try:
    from pricing import (
        DEFAULT_PRICING, FAMILY_PRICING, STATS_DIR, PRICING_FILE,
        load_pricing, get_model_pricing, calculate_cost
    )
except ImportError:
    # Fallback for users who haven't reinstalled yet
    STATS_DIR = Path.home() / ".claude" / "stats"
    PRICING_FILE = STATS_DIR / "pricing.json"

    DEFAULT_PRICING = {
        "claude-opus-4-5-20251101": {"input": 5.00, "output": 25.00, "cache_read": 0.50, "cache_write": 6.25},
        "claude-sonnet-4-20250514": {"input": 3.00, "output": 15.00, "cache_read": 0.30, "cache_write": 3.75},
        "claude-3-5-sonnet-20241022": {"input": 3.00, "output": 15.00, "cache_read": 0.30, "cache_write": 3.75},
        "claude-3-5-haiku-20241022": {"input": 0.80, "output": 4.00, "cache_read": 0.08, "cache_write": 1.00},
    }

    FAMILY_PRICING = {
        "opus": {"input": 15.00, "output": 75.00, "cache_read": 1.50, "cache_write": 18.75},
        "sonnet": {"input": 3.00, "output": 15.00, "cache_read": 0.30, "cache_write": 3.75},
        "haiku": {"input": 1.00, "output": 5.00, "cache_read": 0.10, "cache_write": 1.25},
    }

    def get_family_pricing(model: str) -> dict:
        model_lower = model.lower()
        if "opus" in model_lower:
            return FAMILY_PRICING["opus"]
        elif "haiku" in model_lower:
            return FAMILY_PRICING["haiku"]
        return FAMILY_PRICING["sonnet"]

    def load_pricing() -> dict:
        pricing = DEFAULT_PRICING.copy()
        if PRICING_FILE.exists():
            try:
                with open(PRICING_FILE, "r") as f:
                    pricing.update(json.load(f))
            except (json.JSONDecodeError, FileNotFoundError, PermissionError):
                pass
        return pricing

    def get_model_pricing(model: str, pricing: dict) -> dict:
        if model in pricing:
            return pricing[model]
        for key in pricing:
            if key in model or model in key:
                return pricing[key]
        return get_family_pricing(model)

    def calculate_cost(tokens: dict, model: str, pricing: dict) -> float:
        mp = get_model_pricing(model, pricing)
        cost = 0.0
        cost += (tokens.get("input_tokens", 0) / 1_000_000) * mp.get("input", 0)
        cost += (tokens.get("output_tokens", 0) / 1_000_000) * mp.get("output", 0)
        cost += (tokens.get("cache_read_tokens", 0) / 1_000_000) * mp.get("cache_read", 0)
        cost += (tokens.get("cache_creation_tokens", 0) / 1_000_000) * mp.get("cache_write", 0)
        return cost

REFRESH_INTERVAL = 2  # seconds
CONTENT_WIDTH = 75  # Fixed content width for centering

TIMESERIES_FILE = STATS_DIR / "timeseries.json"


def format_cost(cost: float) -> str:
    """Format cost with appropriate precision."""
    if cost >= 100:
        return f"${cost:,.0f}"
    elif cost >= 10:
        return f"${cost:.2f}"
    elif cost >= 0.01:
        return f"${cost:.3f}"
    elif cost > 0:
        return f"${cost:.4f}"
    return "$0.00"


def get_cost_color(cost: float) -> str:
    """Return ANSI color code based on cost magnitude."""
    if cost >= 10:
        return "\033[91m"  # BRIGHT_RED
    elif cost >= 1:
        return "\033[93m"  # BRIGHT_YELLOW
    return "\033[92m"  # BRIGHT_GREEN


def get_terminal_width() -> int:
    """Get terminal width."""
    try:
        return os.get_terminal_size().columns
    except OSError:
        return 80


def strip_ansi(text: str) -> str:
    """Remove ANSI escape codes from text."""
    return re.sub(r'\033\[[0-9;]*m', '', text)


def center_line(line: str, width: int) -> str:
    """Center a line within the given width."""
    visible_len = len(strip_ansi(line))
    padding = (width - min(visible_len, CONTENT_WIDTH)) // 2
    if padding > 0:
        return ' ' * padding + line
    return line


def center_output(lines: list[str]) -> list[str]:
    """Center all lines based on terminal width."""
    term_width = get_terminal_width()
    return [center_line(line, term_width) for line in lines]


class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    UNDERLINE = "\033[4m"
    REVERSE = "\033[7m"

    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    MAGENTA = "\033[35m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"

    BRIGHT_RED = "\033[91m"
    BRIGHT_GREEN = "\033[92m"
    BRIGHT_YELLOW = "\033[93m"
    BRIGHT_BLUE = "\033[94m"
    BRIGHT_MAGENTA = "\033[95m"
    BRIGHT_CYAN = "\033[96m"
    BRIGHT_WHITE = "\033[97m"


# Block characters for graphs
BLOCKS = {
    'full': '‚ñà',
    'seven_eighths': '‚ñâ',
    'three_quarters': '‚ñä',
    'five_eighths': '‚ñã',
    'half': '‚ñå',
    'three_eighths': '‚ñç',
    'quarter': '‚ñé',
    'eighth': '‚ñè',
    'empty': '‚ñë',
}

SPARK = " ‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà"

MODEL_COLORS = {
    "claude-opus-4-5-20251101": (Colors.BRIGHT_MAGENTA, "Opus 4.5"),
    "claude-sonnet-4-20250514": (Colors.BRIGHT_BLUE, "Sonnet 4"),
    "claude-3-5-sonnet-20241022": (Colors.BLUE, "Sonnet 3.5"),
    "claude-3-5-haiku-20241022": (Colors.CYAN, "Haiku 3.5"),
    "claude-haiku": (Colors.CYAN, "Haiku"),
}


def get_model_display(model: str) -> tuple:
    if model in MODEL_COLORS:
        return MODEL_COLORS[model]
    for key, val in MODEL_COLORS.items():
        if key in model or model in key:
            return val
    return (Colors.BRIGHT_WHITE, model[:20])


def format_number(n: int) -> str:
    return f"{n:,}"


def format_tokens_short(n: int) -> str:
    if n >= 1_000_000:
        return f"{n/1_000_000:.1f}M"
    elif n >= 1_000:
        return f"{n/1_000:.1f}K"
    return str(n)


def load_stats(date_str: str) -> Optional[dict]:
    stats_file = STATS_DIR / f"{date_str}.json"
    if stats_file.exists():
        try:
            with open(stats_file, "r") as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError, PermissionError):
            pass
    return None


def parse_iso_timestamp(ts: str) -> datetime:
    """Parse ISO timestamp string to datetime."""
    ts = ts.replace("Z", "+00:00")
    try:
        return datetime.fromisoformat(ts)
    except ValueError:
        if "+" in ts:
            ts = ts.split("+")[0]
        elif ts.endswith("Z"):
            ts = ts[:-1]
        return datetime.fromisoformat(ts)


def load_timeseries() -> dict:
    """Load timeseries data for TPS graph."""
    if TIMESERIES_FILE.exists():
        try:
            with open(TIMESERIES_FILE, "r") as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError, PermissionError):
            pass
    return {"version": 1, "buckets": {}, "seen_request_ids": []}


def get_recent_buckets(window_minutes: int = 30) -> list[dict]:
    """Get TPS buckets for the last N minutes.

    Returns a list of bucket data, one per minute, with zeros for missing minutes.
    Uses absolute minute keys for historical consistency.
    """
    data = load_timeseries()
    buckets = data.get("buckets", {})

    now = datetime.now()
    result = []

    for i in range(window_minutes):
        # Calculate minute slot from oldest to newest
        minute_dt = now - timedelta(minutes=window_minutes - 1 - i)
        bucket_key = minute_dt.strftime("%Y-%m-%dT%H:%M")

        if bucket_key in buckets:
            bucket = buckets[bucket_key]
            result.append({
                "minute": minute_dt.strftime("%H:%M"),
                "output_tps": bucket.get("output_tps", 0),
                "total_tps": bucket.get("total_tps", 0),
                "output_tokens": bucket.get("output_tokens", 0),
                "total_tokens": bucket.get("total_tokens", 0),
                "request_count": bucket.get("request_count", 0),
                "cost": bucket.get("cost", 0.0),
            })
        else:
            result.append({
                "minute": minute_dt.strftime("%H:%M"),
                "output_tps": 0,
                "total_tps": 0,
                "output_tokens": 0,
                "total_tokens": 0,
                "request_count": 0,
                "cost": 0.0,
            })

    return result


def aggregate_stats(from_date: str, to_date: str) -> dict:
    """Aggregate stats across a date range with detailed daily breakdown."""
    pricing = load_pricing()
    result = {
        "input_tokens": 0,
        "output_tokens": 0,
        "cache_read_tokens": 0,
        "cache_creation_tokens": 0,
        "total_tokens": 0,
        "request_count": 0,
        "session_count": 0,
        "cost": 0.0,
        "by_model": {},
        "daily": [],
    }

    current = datetime.strptime(from_date, "%Y-%m-%d")
    end = datetime.strptime(to_date, "%Y-%m-%d")

    # Ensure from_date <= to_date
    if current > end:
        current, end = end, current

    while current <= end:
        date_str = current.strftime("%Y-%m-%d")
        stats = load_stats(date_str)

        daily_entry = {
            "date": date_str,
            "input_tokens": 0,
            "output_tokens": 0,
            "cache_read_tokens": 0,
            "cache_creation_tokens": 0,
            "total_tokens": 0,
            "request_count": 0,
            "session_count": 0,
            "cost": 0.0,
        }

        if stats:
            totals = stats.get("daily_totals", {})
            daily_entry["input_tokens"] = totals.get("input_tokens", 0)
            daily_entry["output_tokens"] = totals.get("output_tokens", 0)
            daily_entry["cache_read_tokens"] = totals.get("cache_read_tokens", 0)
            daily_entry["cache_creation_tokens"] = totals.get("cache_creation_tokens", 0)
            daily_entry["total_tokens"] = totals.get("total_tokens", 0)
            daily_entry["request_count"] = totals.get("request_count", 0)
            daily_entry["session_count"] = totals.get("session_count", 0)
            daily_entry["cost"] = totals.get("cost", 0.0)

            # Recalculate cost if not stored (backward compatibility)
            if daily_entry["cost"] == 0.0 and daily_entry["total_tokens"] > 0:
                for model, ms in stats.get("by_model", {}).items():
                    daily_entry["cost"] += calculate_cost(ms, model, pricing)

            result["input_tokens"] += daily_entry["input_tokens"]
            result["output_tokens"] += daily_entry["output_tokens"]
            result["cache_read_tokens"] += daily_entry["cache_read_tokens"]
            result["cache_creation_tokens"] += daily_entry["cache_creation_tokens"]
            result["total_tokens"] += daily_entry["total_tokens"]
            result["request_count"] += daily_entry["request_count"]
            result["session_count"] += daily_entry["session_count"]
            result["cost"] += daily_entry["cost"]

            for model, model_stats in stats.get("by_model", {}).items():
                if model not in result["by_model"]:
                    result["by_model"][model] = {
                        "input_tokens": 0,
                        "output_tokens": 0,
                        "cache_read_tokens": 0,
                        "cache_creation_tokens": 0,
                        "request_count": 0,
                        "cost": 0.0,
                    }
                for key in ["input_tokens", "output_tokens", "cache_read_tokens", "cache_creation_tokens", "request_count"]:
                    result["by_model"][model][key] += model_stats.get(key, 0)
                # Aggregate cost, recalculate if not stored
                model_cost = model_stats.get("cost", 0.0)
                if model_cost == 0.0:
                    model_cost = calculate_cost(model_stats, model, pricing)
                result["by_model"][model]["cost"] += model_cost

        result["daily"].append(daily_entry)
        current += timedelta(days=1)

    return result


def get_key(timeout: float = REFRESH_INTERVAL):
    """Get a single keypress with timeout. Returns None if no key pressed."""
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        # Wait for input with timeout
        rlist, _, _ = select.select([sys.stdin], [], [], timeout)
        if not rlist:
            return None  # Timeout, no key pressed

        ch = sys.stdin.read(1)
        if ch == '\x1b':
            # Check if more chars available for escape sequence
            rlist, _, _ = select.select([sys.stdin], [], [], 0.01)
            if rlist:
                ch2 = sys.stdin.read(1)
                if ch2 == '[':
                    rlist, _, _ = select.select([sys.stdin], [], [], 0.01)
                    if rlist:
                        ch3 = sys.stdin.read(1)
                        if ch3 == 'A':
                            return 'UP'
                        elif ch3 == 'B':
                            return 'DOWN'
                        elif ch3 == 'C':
                            return 'RIGHT'
                        elif ch3 == 'D':
                            return 'LEFT'
            return 'ESC'
        return ch
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)


def sparkline(values: list, width: int = 7) -> str:
    if not values:
        return SPARK[0] * width
    max_val = max(values)
    if max_val == 0:
        return SPARK[0] * width
    result = ""
    for v in values[-width:]:
        idx = int((v / max_val) * (len(SPARK) - 1))
        result += SPARK[idx]
    return result.ljust(width, SPARK[0])


def mini_bar(value: int, max_val: int, width: int = 10, char: str = '‚ñà', empty: str = ' ') -> str:
    """Create a mini horizontal bar."""
    if max_val == 0 or value == 0:
        return ' ' * width
    filled = int((value / max_val) * width)
    if filled == 0 and value > 0:
        filled = 1  # Show at least 1 char if non-zero
    return char * filled + ' ' * (width - filled)


def clear_screen():
    # Move cursor to home position, then clear from cursor to end of screen
    # Using \033[H\033[J instead of \033[2J\033[H avoids screen flicker
    print("\033[H\033[J", end="", flush=True)


def hide_cursor():
    print("\033[?25l", end="", flush=True)


def show_cursor():
    print("\033[?25h", end="", flush=True)


def draw_header() -> list[str]:
    lines = []
    now = datetime.now()
    lines.append("")
    lines.append(f"  {Colors.BOLD}{Colors.BRIGHT_CYAN}‚ï≠{'‚îÄ' * 50}‚ïÆ{Colors.RESET}")
    lines.append(f"  {Colors.BOLD}{Colors.BRIGHT_CYAN}‚îÇ{Colors.BRIGHT_WHITE}        ‚ö° CLAUDE CODE TOKEN STATS ‚ö°            {Colors.BRIGHT_CYAN}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BOLD}{Colors.BRIGHT_CYAN}‚ï∞{'‚îÄ' * 50}‚ïØ{Colors.RESET}")
    lines.append(f"  {Colors.DIM}{now.strftime('%A, %B %d, %Y ‚Ä¢ %H:%M')}{Colors.RESET}")
    lines.append("")
    return lines


def draw_date_picker(from_date: datetime, to_date: datetime, selected: int) -> list[str]:
    lines = []
    lines.append(f"  {Colors.BOLD}üìÖ Date Range{Colors.RESET}  {Colors.DIM}‚Üê‚Üí switch  ‚Üë‚Üì adjust  T today  W week  M month  Q quit{Colors.RESET}")
    lines.append("")

    from_str = from_date.strftime("%Y-%m-%d")
    to_str = to_date.strftime("%Y-%m-%d")

    if selected == 0:
        from_style = f"{Colors.REVERSE}{Colors.BRIGHT_CYAN}"
        to_style = Colors.DIM
    else:
        from_style = Colors.DIM
        to_style = f"{Colors.REVERSE}{Colors.BRIGHT_CYAN}"

    lines.append(f"  {Colors.CYAN}From:{Colors.RESET} {from_style} {from_str} {Colors.RESET}    {Colors.CYAN}To:{Colors.RESET} {to_style} {to_str} {Colors.RESET}")
    lines.append("")

    return lines


def draw_summary(stats: dict, from_date: str, to_date: str) -> list[str]:
    lines = []

    from_dt = datetime.strptime(from_date, "%Y-%m-%d")
    to_dt = datetime.strptime(to_date, "%Y-%m-%d")
    days = (to_dt - from_dt).days + 1

    if from_date == to_date:
        range_label = from_dt.strftime("%b %d, %Y")
    else:
        range_label = f"{from_dt.strftime('%b %d')} ‚Üí {to_dt.strftime('%b %d, %Y')} ({days} days)"

    lines.append(f"  {Colors.BOLD}{Colors.GREEN}üìä Summary: {range_label}{Colors.RESET}")
    lines.append(f"  {Colors.DIM}{'‚îÄ' * 70}{Colors.RESET}")

    # Calculate non-cached vs cached
    non_cached = stats['input_tokens'] + stats['output_tokens']
    cached = stats['cache_read_tokens'] + stats['cache_creation_tokens']
    total = stats['total_tokens']

    total_cost = stats.get('cost', 0.0)
    cost_color = get_cost_color(total_cost)

    lines.append("")
    lines.append(f"  {Colors.BRIGHT_WHITE}{Colors.BOLD}TOTAL{Colors.RESET}          {Colors.BRIGHT_GREEN}{format_number(total):>15}{Colors.RESET}   {Colors.DIM}‚îÇ{Colors.RESET}  {cost_color}{Colors.BOLD}{format_cost(total_cost)}{Colors.RESET}  {Colors.DIM}‚îÇ{Colors.RESET}  Sessions: {stats['session_count']}  Requests: {stats['request_count']}")
    lines.append("")

    # Non-cached section
    lines.append(f"  {Colors.BOLD}Direct (non-cached){Colors.RESET}                    {Colors.BOLD}Cached{Colors.RESET}")
    lines.append(f"  {Colors.CYAN}‚Üì Input{Colors.RESET}    {format_number(stats['input_tokens']):>12}          {Colors.YELLOW}‚Üì Read{Colors.RESET}     {format_number(stats['cache_read_tokens']):>12}")
    lines.append(f"  {Colors.MAGENTA}‚Üë Output{Colors.RESET}   {format_number(stats['output_tokens']):>12}          {Colors.BLUE}‚Üë Write{Colors.RESET}    {format_number(stats['cache_creation_tokens']):>12}")
    lines.append(f"  {Colors.DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ{Colors.RESET}                 {Colors.DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ{Colors.RESET}")
    lines.append(f"  {Colors.WHITE}Subtotal{Colors.RESET}   {format_number(non_cached):>12}          {Colors.WHITE}Subtotal{Colors.RESET}   {format_number(cached):>12}")
    lines.append("")

    return lines


def draw_model_breakdown(by_model: dict) -> list[str]:
    lines = []
    if not by_model:
        return lines

    lines.append(f"  {Colors.BOLD}Per-Model Breakdown{Colors.RESET}")
    lines.append(f"  {Colors.DIM}{'‚îÄ' * 75}{Colors.RESET}")
    # Header with fixed column widths
    lines.append(
        f"  {Colors.DIM}{'Model':<14}{'‚ÜìInput':>10}{'‚ÜëOutput':>10}{'Cache‚Üì':>10}{'Cache‚Üë':>10}{'Total':>10}{'Cost':>11}{Colors.RESET}"
    )

    for model, s in sorted(by_model.items()):
        color, display_name = get_model_display(model)
        total = s.get("input_tokens", 0) + s.get("output_tokens", 0) + s.get("cache_read_tokens", 0) + s.get("cache_creation_tokens", 0)
        cost = s.get("cost", 0.0)
        cost_color = get_cost_color(cost)
        lines.append(
            f"  {color}{display_name:<14}{Colors.RESET}"
            f"{Colors.CYAN}{format_tokens_short(s.get('input_tokens', 0)):>10}{Colors.RESET}"
            f"{Colors.MAGENTA}{format_tokens_short(s.get('output_tokens', 0)):>10}{Colors.RESET}"
            f"{Colors.YELLOW}{format_tokens_short(s.get('cache_read_tokens', 0)):>10}{Colors.RESET}"
            f"{Colors.BLUE}{format_tokens_short(s.get('cache_creation_tokens', 0)):>10}{Colors.RESET}"
            f"{Colors.BRIGHT_WHITE}{format_tokens_short(total):>10}{Colors.RESET}"
            f"{cost_color}{format_cost(cost):>11}{Colors.RESET}"
        )

    lines.append("")
    return lines


def draw_daily_breakdown(daily: list[dict]) -> list[str]:
    """Draw detailed daily breakdown with mini graphs."""
    lines = []

    if not daily:
        return lines

    # Calculate all maxes in a single pass for better performance
    max_input = max_output = max_cache_r = max_cache_w = 0
    for d in daily:
        max_input = max(max_input, d["input_tokens"])
        max_output = max(max_output, d["output_tokens"])
        max_cache_r = max(max_cache_r, d["cache_read_tokens"])
        max_cache_w = max(max_cache_w, d["cache_creation_tokens"])
    max_input = max_input or 1
    max_output = max_output or 1
    max_cache_r = max_cache_r or 1
    max_cache_w = max_cache_w or 1

    # Limit display to last 10 days if too many
    display_daily = daily[-10:] if len(daily) > 10 else daily

    # Column widths: date=8, bar+val=14 each (6 bar + 8 val), total=10, cost=10
    lines.append(f"  {Colors.BOLD}Daily Breakdown{Colors.RESET}")
    lines.append(f"  {Colors.DIM}{'‚îÄ' * 75}{Colors.RESET}")
    lines.append(
        f"  {Colors.DIM}{'Date':<8}{'‚ÜìInput':>14}{'‚ÜëOutput':>14}{'Cache‚Üì':>14}{'Cache‚Üë':>14}{'Total':>10}{'Cost':>10}{Colors.RESET}"
    )

    for d in display_daily:
        date_obj = datetime.strptime(d["date"], "%Y-%m-%d")
        is_today = d["date"] == datetime.now().strftime("%Y-%m-%d")

        if is_today:
            date_str = f"{Colors.BRIGHT_GREEN}{date_obj.strftime('%b %d'):<8}{Colors.RESET}"
            marker = " ‚óÄ"
        else:
            date_str = f"{Colors.DIM}{date_obj.strftime('%b %d'):<8}{Colors.RESET}"
            marker = ""

        # Mini bars for each metric (6 chars) + value (8 chars) = 14 total
        bar_w = 6
        inp_bar = mini_bar(d["input_tokens"], max_input, bar_w)
        out_bar = mini_bar(d["output_tokens"], max_output, bar_w)
        cr_bar = mini_bar(d["cache_read_tokens"], max_cache_r, bar_w)
        cw_bar = mini_bar(d["cache_creation_tokens"], max_cache_w, bar_w)

        inp_val = format_tokens_short(d["input_tokens"])
        out_val = format_tokens_short(d["output_tokens"])
        cr_val = format_tokens_short(d["cache_read_tokens"])
        cw_val = format_tokens_short(d["cache_creation_tokens"])
        total_val = format_tokens_short(d["total_tokens"])
        cost = d.get("cost", 0.0)
        cost_color = get_cost_color(cost)

        lines.append(
            f"  {date_str}"
            f"{Colors.CYAN}{inp_bar}{inp_val:>8}{Colors.RESET}"
            f"{Colors.MAGENTA}{out_bar}{out_val:>8}{Colors.RESET}"
            f"{Colors.YELLOW}{cr_bar}{cr_val:>8}{Colors.RESET}"
            f"{Colors.BLUE}{cw_bar}{cw_val:>8}{Colors.RESET}"
            f"{Colors.BRIGHT_WHITE}{total_val:>10}{Colors.RESET}"
            f"{cost_color}{format_cost(cost):>10}{Colors.RESET}{marker}"
        )

    if len(daily) > 10:
        lines.append(f"  {Colors.DIM}... showing last 10 of {len(daily)} days{Colors.RESET}")

    lines.append("")
    return lines


def sparkline_float(values: list, width: int = 7) -> str:
    """Sparkline for float values (like costs)."""
    if not values:
        return SPARK[0] * width
    max_val = max(values)
    if max_val == 0:
        return SPARK[0] * width
    result = ""
    for v in values[-width:]:
        idx = int((v / max_val) * (len(SPARK) - 1))
        result += SPARK[idx]
    return result.ljust(width, SPARK[0])


def draw_sparkline_graphs(daily: list[dict]) -> list[str]:
    """Draw sparkline trend graphs."""
    lines = []

    if not daily or len(daily) < 2:
        return lines

    lines.append(f"  {Colors.BOLD}Trends{Colors.RESET} {Colors.DIM}(last {len(daily)} days){Colors.RESET}")
    lines.append(f"  {Colors.DIM}{'‚îÄ' * 40}{Colors.RESET}")

    # Extract values
    inputs = [d["input_tokens"] for d in daily]
    outputs = [d["output_tokens"] for d in daily]
    cache_r = [d["cache_read_tokens"] for d in daily]
    cache_w = [d["cache_creation_tokens"] for d in daily]
    totals = [d["total_tokens"] for d in daily]
    costs = [d.get("cost", 0.0) for d in daily]

    spark_width = min(len(daily), 14)
    total_cost = sum(costs)
    cost_color = get_cost_color(total_cost)

    lines.append(f"  {Colors.CYAN}Input    {Colors.RESET} {Colors.CYAN}{sparkline(inputs, spark_width)}{Colors.RESET}  {Colors.DIM}{format_tokens_short(sum(inputs))}{Colors.RESET}")
    lines.append(f"  {Colors.MAGENTA}Output   {Colors.RESET} {Colors.MAGENTA}{sparkline(outputs, spark_width)}{Colors.RESET}  {Colors.DIM}{format_tokens_short(sum(outputs))}{Colors.RESET}")
    lines.append(f"  {Colors.YELLOW}Cache R  {Colors.RESET} {Colors.YELLOW}{sparkline(cache_r, spark_width)}{Colors.RESET}  {Colors.DIM}{format_tokens_short(sum(cache_r))}{Colors.RESET}")
    lines.append(f"  {Colors.BLUE}Cache W  {Colors.RESET} {Colors.BLUE}{sparkline(cache_w, spark_width)}{Colors.RESET}  {Colors.DIM}{format_tokens_short(sum(cache_w))}{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_WHITE}Total    {Colors.RESET} {Colors.BRIGHT_GREEN}{sparkline(totals, spark_width)}{Colors.RESET}  {Colors.DIM}{format_tokens_short(sum(totals))}{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_YELLOW}Cost     {Colors.RESET} {Colors.BRIGHT_YELLOW}{sparkline_float(costs, spark_width)}{Colors.RESET}  {cost_color}{format_cost(total_cost)}{Colors.RESET}")
    lines.append("")

    return lines


def format_tps(v: float) -> str:
    """Format TPS value."""
    if v >= 1000:
        return f"{v/1000:.1f}K"
    elif v >= 100:
        return f"{v:.0f}"
    elif v >= 10:
        return f"{v:.1f}"
    elif v > 0:
        return f"{v:.1f}"
    return "0"


def draw_btop_graph(values: list, height: int, width: int, color: str, label: str = "") -> list[str]:
    """Draw a btop-style area graph with filled blocks."""
    lines = []
    max_val = max(values) if values else 0
    if max_val <= 0:
        max_val = 1

    # Scale values to fill width (stretch data to fit)
    if not values:
        sampled = [0] * width
    else:
        sampled = []
        for i in range(width):
            val_idx = int(i * len(values) / width)
            sampled.append(values[min(val_idx, len(values) - 1)])

    # Build rows from top to bottom
    for row in range(height - 1, -1, -1):
        threshold = (row / height) * max_val
        row_chars = ""
        for val in sampled:
            if val > threshold:
                # Calculate fill level within this cell
                cell_bottom = threshold
                cell_top = ((row + 1) / height) * max_val
                fill_ratio = min(1.0, (val - cell_bottom) / (cell_top - cell_bottom)) if cell_top > cell_bottom else 1.0
                if fill_ratio >= 0.875:
                    row_chars += "‚ñà"
                elif fill_ratio >= 0.75:
                    row_chars += "‚ñá"
                elif fill_ratio >= 0.625:
                    row_chars += "‚ñÜ"
                elif fill_ratio >= 0.5:
                    row_chars += "‚ñÖ"
                elif fill_ratio >= 0.375:
                    row_chars += "‚ñÑ"
                elif fill_ratio >= 0.25:
                    row_chars += "‚ñÉ"
                elif fill_ratio >= 0.125:
                    row_chars += "‚ñÇ"
                else:
                    row_chars += "‚ñÅ"
            else:
                row_chars += " "
        lines.append(f"{color}{row_chars}{Colors.RESET}")

    return lines


def draw_realtime_view(buckets: list[dict]) -> list[str]:
    """Draw btop-style real-time monitoring view."""
    lines = []
    now = datetime.now()

    # Header
    lines.append("")
    lines.append(f"  {Colors.BOLD}{Colors.BRIGHT_CYAN}‚ï≠{'‚îÄ' * 68}‚ïÆ{Colors.RESET}")
    lines.append(f"  {Colors.BOLD}{Colors.BRIGHT_CYAN}‚îÇ{Colors.BRIGHT_WHITE}              ‚ö° REAL-TIME TOKEN THROUGHPUT ‚ö°                     {Colors.BRIGHT_CYAN}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BOLD}{Colors.BRIGHT_CYAN}‚ï∞{'‚îÄ' * 68}‚ïØ{Colors.RESET}")
    lines.append(f"  {Colors.DIM}{now.strftime('%H:%M:%S')} ‚Ä¢ Press S for stats view ‚Ä¢ Q to quit{Colors.RESET}")
    lines.append("")

    # Extract values
    output_values = [b["output_tps"] for b in buckets]
    total_values = [b["total_tps"] for b in buckets]

    # Calculate stats
    current_output = next((v for v in reversed(output_values) if v > 0), 0)
    current_total = next((v for v in reversed(total_values) if v > 0), 0)
    peak_output = max(output_values) if output_values else 0
    peak_total = max(total_values) if total_values else 0
    avg_output = sum(v for v in output_values if v > 0) / max(1, sum(1 for v in output_values if v > 0))
    avg_total = sum(v for v in total_values if v > 0) / max(1, sum(1 for v in total_values if v > 0))

    graph_width = 60
    graph_height = 8

    # Output TPS Graph
    lines.append(f"  {Colors.BRIGHT_MAGENTA}‚îå{'‚îÄ' * (graph_width + 2)}‚îê{Colors.RESET}")
    out_header = f"Output tok/s  Now:{format_tps(current_output):>5}/s  Peak:{format_tps(peak_output):>5}/s  Avg:{format_tps(avg_output):>5}/s"
    lines.append(f"  {Colors.BRIGHT_MAGENTA}‚îÇ{Colors.RESET} {Colors.BOLD}{out_header:<{graph_width}}{Colors.RESET} {Colors.BRIGHT_MAGENTA}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_MAGENTA}‚îú{'‚îÄ' * (graph_width + 2)}‚î§{Colors.RESET}")

    # Draw output graph
    graph_lines = draw_btop_graph(output_values, graph_height, graph_width, Colors.MAGENTA)
    for gl in graph_lines:
        lines.append(f"  {Colors.BRIGHT_MAGENTA}‚îÇ{Colors.RESET} {gl} {Colors.BRIGHT_MAGENTA}‚îÇ{Colors.RESET}")

    lines.append(f"  {Colors.BRIGHT_MAGENTA}‚îú{'‚îÄ' * (graph_width + 2)}‚î§{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_MAGENTA}‚îÇ{Colors.RESET} {Colors.DIM}-30m{' ' * (graph_width - 7)}now{Colors.RESET} {Colors.BRIGHT_MAGENTA}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_MAGENTA}‚îî{'‚îÄ' * (graph_width + 2)}‚îò{Colors.RESET}")
    lines.append("")

    # Total TPS Graph
    lines.append(f"  {Colors.BRIGHT_CYAN}‚îå{'‚îÄ' * (graph_width + 2)}‚îê{Colors.RESET}")
    tot_header = f"Total tok/s   Now:{format_tps(current_total):>5}/s  Peak:{format_tps(peak_total):>5}/s  Avg:{format_tps(avg_total):>5}/s"
    lines.append(f"  {Colors.BRIGHT_CYAN}‚îÇ{Colors.RESET} {Colors.BOLD}{tot_header:<{graph_width}}{Colors.RESET} {Colors.BRIGHT_CYAN}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_CYAN}‚îú{'‚îÄ' * (graph_width + 2)}‚î§{Colors.RESET}")

    # Draw total graph
    graph_lines = draw_btop_graph(total_values, graph_height, graph_width, Colors.CYAN)
    for gl in graph_lines:
        lines.append(f"  {Colors.BRIGHT_CYAN}‚îÇ{Colors.RESET} {gl} {Colors.BRIGHT_CYAN}‚îÇ{Colors.RESET}")

    lines.append(f"  {Colors.BRIGHT_CYAN}‚îú{'‚îÄ' * (graph_width + 2)}‚î§{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_CYAN}‚îÇ{Colors.RESET} {Colors.DIM}-30m{' ' * (graph_width - 7)}now{Colors.RESET} {Colors.BRIGHT_CYAN}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_CYAN}‚îî{'‚îÄ' * (graph_width + 2)}‚îò{Colors.RESET}")
    lines.append("")

    # Quick stats panel
    total_requests = sum(b["request_count"] for b in buckets)
    total_output = sum(b["output_tokens"] for b in buckets)
    total_all = sum(b["total_tokens"] for b in buckets)
    total_cost = sum(b["cost"] for b in buckets)
    cost_color = get_cost_color(total_cost)
    active_mins = sum(1 for b in buckets if b['request_count'] > 0)

    avg_req = total_requests / max(1, active_mins)

    lines.append(f"  {Colors.BRIGHT_GREEN}‚îå{'‚îÄ' * 29}‚îê{Colors.RESET}  {Colors.BRIGHT_YELLOW}‚îå{'‚îÄ' * 29}‚îê{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_GREEN}‚îÇ{Colors.RESET} {Colors.BOLD}Last 30 Minutes{Colors.RESET}             {Colors.BRIGHT_GREEN}‚îÇ{Colors.RESET}  {Colors.BRIGHT_YELLOW}‚îÇ{Colors.RESET} {Colors.BOLD}Activity{Colors.RESET}                    {Colors.BRIGHT_YELLOW}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_GREEN}‚îú{'‚îÄ' * 29}‚î§{Colors.RESET}  {Colors.BRIGHT_YELLOW}‚îú{'‚îÄ' * 29}‚î§{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_GREEN}‚îÇ{Colors.RESET}  Requests:      {total_requests:>11} {Colors.BRIGHT_GREEN}‚îÇ{Colors.RESET}  {Colors.BRIGHT_YELLOW}‚îÇ{Colors.RESET}  Active mins:       {active_mins:>7} {Colors.BRIGHT_YELLOW}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_GREEN}‚îÇ{Colors.RESET}  Output tokens: {format_tokens_short(total_output):>11} {Colors.BRIGHT_GREEN}‚îÇ{Colors.RESET}  {Colors.BRIGHT_YELLOW}‚îÇ{Colors.RESET}  Idle mins:         {30 - active_mins:>7} {Colors.BRIGHT_YELLOW}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_GREEN}‚îÇ{Colors.RESET}  Total tokens:  {format_tokens_short(total_all):>11} {Colors.BRIGHT_GREEN}‚îÇ{Colors.RESET}  {Colors.BRIGHT_YELLOW}‚îÇ{Colors.RESET}  Avg req/min:       {avg_req:>7.1f} {Colors.BRIGHT_YELLOW}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_GREEN}‚îÇ{Colors.RESET}  Cost:          {cost_color}{format_cost(total_cost):>11}{Colors.RESET} {Colors.BRIGHT_GREEN}‚îÇ{Colors.RESET}  {Colors.BRIGHT_YELLOW}‚îÇ{Colors.RESET}                             {Colors.BRIGHT_YELLOW}‚îÇ{Colors.RESET}")
    lines.append(f"  {Colors.BRIGHT_GREEN}‚îî{'‚îÄ' * 29}‚îò{Colors.RESET}  {Colors.BRIGHT_YELLOW}‚îî{'‚îÄ' * 29}‚îò{Colors.RESET}")
    lines.append("")
    lines.append(f"  {Colors.DIM}Auto-refreshing every {REFRESH_INTERVAL}s{Colors.RESET}")
    lines.append("")

    return lines


def draw_stacked_bar_chart(daily: list[dict]) -> list[str]:
    """Draw a stacked bar chart showing composition."""
    lines = []

    if not daily:
        return lines

    display_daily = daily[-7:] if len(daily) > 7 else daily
    max_total = max(d["total_tokens"] for d in display_daily) or 1

    lines.append(f"  {Colors.BOLD}Composition{Colors.RESET} {Colors.DIM}(stacked){Colors.RESET}")
    lines.append(f"  {Colors.DIM}{'‚îÄ' * 50}{Colors.RESET}")
    lines.append(f"  {Colors.DIM}Legend: {Colors.CYAN}‚ñ†{Colors.RESET}{Colors.DIM}Input {Colors.MAGENTA}‚ñ†{Colors.RESET}{Colors.DIM}Output {Colors.YELLOW}‚ñ†{Colors.RESET}{Colors.DIM}CacheR {Colors.BLUE}‚ñ†{Colors.RESET}{Colors.DIM}CacheW{Colors.RESET}")
    lines.append("")

    bar_width = 35

    for d in display_daily:
        date_obj = datetime.strptime(d["date"], "%Y-%m-%d")
        is_today = d["date"] == datetime.now().strftime("%Y-%m-%d")

        if is_today:
            date_str = f"{Colors.BRIGHT_GREEN}{date_obj.strftime('%a')}{Colors.RESET}"
        else:
            date_str = f"{Colors.DIM}{date_obj.strftime('%a')}{Colors.RESET}"

        total = d["total_tokens"]
        if total == 0:
            lines.append(f"  {date_str:>10} {Colors.DIM}{'‚ñë' * bar_width}{Colors.RESET}      0")
            continue

        # Calculate proportions
        scale = bar_width / max_total
        inp_w = int(d["input_tokens"] * scale)
        out_w = int(d["output_tokens"] * scale)
        cr_w = int(d["cache_read_tokens"] * scale)
        cw_w = int(d["cache_creation_tokens"] * scale)

        # Ensure at least 1 char if non-zero
        if d["input_tokens"] > 0 and inp_w == 0:
            inp_w = 1
        if d["output_tokens"] > 0 and out_w == 0:
            out_w = 1
        if d["cache_read_tokens"] > 0 and cr_w == 0:
            cr_w = 1
        if d["cache_creation_tokens"] > 0 and cw_w == 0:
            cw_w = 1

        # Build stacked bar
        bar = (
            f"{Colors.CYAN}{'‚ñà' * inp_w}{Colors.RESET}"
            f"{Colors.MAGENTA}{'‚ñà' * out_w}{Colors.RESET}"
            f"{Colors.YELLOW}{'‚ñà' * cr_w}{Colors.RESET}"
            f"{Colors.BLUE}{'‚ñà' * cw_w}{Colors.RESET}"
        )

        # Pad to width
        used = inp_w + out_w + cr_w + cw_w
        padding = bar_width - used
        if padding > 0:
            bar += f"{Colors.DIM}{'‚ñë' * padding}{Colors.RESET}"

        lines.append(f"  {date_str:>10} {bar} {format_tokens_short(total):>6}")

    lines.append("")
    return lines


def interactive_mode():
    """Run interactive date picker mode with stats and realtime views."""
    today = datetime.now()
    from_date = today - timedelta(days=6)
    to_date = today
    selected = 0
    view = 'stats'  # 'stats' or 'realtime'

    # Set up signal handlers for clean exit on Ctrl+C
    def cleanup_handler(signum, frame):
        show_cursor()
        clear_screen()
        sys.exit(0)

    original_sigint = signal.signal(signal.SIGINT, cleanup_handler)
    original_sigterm = signal.signal(signal.SIGTERM, cleanup_handler)

    hide_cursor()

    try:
        while True:
            clear_screen()
            today = datetime.now()  # Update today on each refresh

            if view == 'realtime':
                # Real-time throughput view
                tps_buckets = get_recent_buckets(30)
                output = draw_realtime_view(tps_buckets)
                print("\n".join(center_output(output)), flush=True)

                key = get_key()

                if key is None:
                    continue  # Auto-refresh
                elif key in ('q', 'Q', '\x03'):
                    break
                elif key in ('s', 'S'):
                    view = 'stats'  # Switch to stats view
                continue

            # Stats view
            from_str = from_date.strftime("%Y-%m-%d")
            to_str = to_date.strftime("%Y-%m-%d")

            stats = aggregate_stats(from_str, to_str)

            output = []
            output.extend(draw_header())
            output.extend(draw_date_picker(from_date, to_date, selected))
            output.extend(draw_summary(stats, from_str, to_str))
            output.extend(draw_model_breakdown(stats.get("by_model", {})))
            output.extend(draw_sparkline_graphs(stats.get("daily", [])))
            output.extend(draw_daily_breakdown(stats.get("daily", [])))
            output.append(f"  {Colors.DIM}Stats: ~/.claude/stats/  ‚Ä¢  R: realtime  ‚Ä¢  Auto-refreshing every {REFRESH_INTERVAL}s{Colors.RESET}")
            output.append("")

            print("\n".join(center_output(output)), flush=True)

            key = get_key()

            if key is None:
                continue  # Auto-refresh on timeout
            elif key in ('q', 'Q', '\x03'):
                break
            elif key in ('r', 'R'):
                view = 'realtime'  # Switch to realtime view
            elif key == 'LEFT':
                selected = 0
            elif key == 'RIGHT':
                selected = 1
            elif key == 'UP':
                if selected == 0:
                    from_date += timedelta(days=1)
                    if from_date > to_date:
                        from_date = to_date
                else:
                    to_date += timedelta(days=1)
                    if to_date > today:
                        to_date = today
            elif key == 'DOWN':
                if selected == 0:
                    from_date -= timedelta(days=1)
                else:
                    to_date -= timedelta(days=1)
                    if to_date < from_date:
                        to_date = from_date
            elif key == 't' or key == 'T':
                from_date = today
                to_date = today
            elif key == 'w' or key == 'W':
                from_date = today - timedelta(days=6)
                to_date = today
            elif key == 'm' or key == 'M':
                from_date = today - timedelta(days=29)
                to_date = today

    finally:
        # Restore original signal handlers
        signal.signal(signal.SIGINT, original_sigint)
        signal.signal(signal.SIGTERM, original_sigterm)
        show_cursor()
        clear_screen()


def main():
    if len(sys.argv) > 1 and sys.argv[1] in ('-h', '--help'):
        print(f"""
{Colors.BOLD}Claude Code Token Stats{Colors.RESET}

Usage:
  claude-stats           Interactive mode with date picker

Interactive controls:
  ‚Üê/‚Üí     Switch between From/To dates
  ‚Üë/‚Üì     Adjust selected date by 1 day
  T       Today only
  W       Last 7 days (Week)
  M       Last 30 days (Month)
  Q       Quit

{Colors.DIM}Legend:{Colors.RESET}
  {Colors.CYAN}‚ñ† Input{Colors.RESET}     Direct input tokens
  {Colors.MAGENTA}‚ñ† Output{Colors.RESET}    Direct output tokens
  {Colors.YELLOW}‚ñ† Cache R{Colors.RESET}   Cache read tokens
  {Colors.BLUE}‚ñ† Cache W{Colors.RESET}   Cache write tokens
""")
    else:
        interactive_mode()


if __name__ == "__main__":
    main()
